const { expect } = require("chai");
const { solidityKeccak256 } = require("ethers/lib/utils");
const { ethers } = require("hardhat");
const { gql, request, GraphQLClient } = require("graphql-request");
const { MerkleTree } = require('merkletreejs')
const keccak256 = require('keccak256')



const EMBLEM_LIBRARY_CONTRACT_NAME = "EmblemLibrary";
const EMBLEM_LIBRARY_TEST_CONTRACT_NAME = "EmblemLibraryTest";
const EMBLEM_SUBGRAPH_CONTROLLER_CONTRACT_NAME = "EmblemSubgraphController";

const EMBLEM_MINTER_ROLE = solidityKeccak256(["string"], ["MINTER_ROLE"]);
const EMBLEM_BURNER_ROLE = solidityKeccak256(["string"], ["BURNER_ROLE"]);
const EMBLEM_ORACLE_ROLE = solidityKeccak256(["string"], ["ORACLE_ROLE"]);

const EMBLEM_GQL_ENDPOINT = "https://api.studio.thegraph.com/query/2486/test/2.1.6";


const EMBLEM_EARNED_BADGE_COUNT_QUERY = gql`
    query getMerkleLeaves($startingIndex: Int, $treeSize: Int) {
        earnedBadgeCounts(first: $treeSize, skip: $startingIndex, orderBy: globalBadgeNumber) {
            earnedBadge {
                badgeWinner {
                    id
                }
                definition {
                    badgeDefinitionNumber
                }
            }
        }
    }`

// this should be one of the known badges returned by EMBLEM_GQL_QUERY
const BADGE_STRUCT = {
  winner: "0x819fd65026848d710fe40d8c0439f1220e069398",
  badgeDefinitionNumber: 1
};


describe("EmblemLibrary", function () {
  it("Should hash badges with results equivalent to ethers.utils", async function () {
    const emblemLibraryTestContract = await deployEmblemLibraryTestContract();
    const hashedBadge = await emblemLibraryTestContract.hashBadge(BADGE_STRUCT);
    const javascriptTestHash = hashBadgeStruct(BADGE_STRUCT);
    expect(hashedBadge).to.equal(javascriptTestHash);
  });
});

describe("Badge Merkle Drop", function () {
  it("Should verify merkle proofs generated by javascript", async function () {
    const client = new GraphQLClient(EMBLEM_GQL_ENDPOINT);
    const success = await proveAllLeavesFromTree(0, 256, client)
    expect (success).to.equal(true);
  });
});

describe("Emblem Subgraph Controller", function () {
  it("Should not fail when posting merkle roots", async function () {
    const client = new GraphQLClient(EMBLEM_GQL_ENDPOINT);
    const leaves = await getLeavesFromSubgraph(0, 256, client);
    const hashedLeaves = leaves.map(earnedBadgeCount => hashEarnedBadge(earnedBadgeCount.earnedBadge));
    const tree = new MerkleTree(hashedLeaves, keccak256, { sortPairs: false });
    const root = tree.getHexRoot();
    const subgraphControllerContract = await deploySubgraphControllerContract();
    await subgraphControllerContract.postMerkleRoot(root, 0, 256);
    expect(true).to.equal(true);
  });

  it("Should increment lastBadgeDefinitionNumber when createBadgeDefinition is called", async function () {
    const subgraphControllerContract = await deploySubgraphControllerContract();
    await subgraphControllerContract.createBadgeDefinition(2,4);
    const nextBadgeDefNumber = await subgraphControllerContract.nextBadgeDefinitionNumber();
    expect(nextBadgeDefNumber).to.equal(1);
  });
});


////////////////// HELPERS //////////////////

function hashBadgeStruct(badgeStruct) {
  let hashedBadge = ethers.utils.solidityKeccak256(
    ['address', 'int8'],
    [badgeStruct.winner, badgeStruct.badgeDefinitionNumber]
  );
  return hashedBadge;
}

function hashEarnedBadge(earnedBadge) {
  let hashedBadge = ethers.utils.solidityKeccak256(
    ['address', 'int8'],
    [earnedBadge.badgeWinner.id, earnedBadge.definition.badgeDefinitionNumber]
  );
  return hashedBadge;
}

async function proveAllLeavesFromTree(_startingIndex, _treeSize, client) {
  const leaves = await getLeavesFromSubgraph(_startingIndex, _treeSize, client);
  const hashedLeaves = leaves.map(earnedBadgeCount => hashEarnedBadge(earnedBadgeCount.earnedBadge));
  const tree = new MerkleTree(hashedLeaves, keccak256, { sortPairs: false });
  const emblemLibraryTestContract = await deployEmblemLibraryTestContract();

  let success = true;
  for (let i = 0; i < leaves.length; i++) {
      const earnedBadge = {
          winner: leaves[i].earnedBadge.badgeWinner.id,
          badgeDefinitionNumber: leaves[i].earnedBadge.definition.badgeDefinitionNumber
      };
      const proof = tree.getHexProof(hashedLeaves[i]);
      const positions = tree.getProof(hashedLeaves[i]).map(x => x.position === 'right' ? 1 : 0);

      success = await emblemLibraryTestContract.verifyBadge(
          earnedBadge, 
          proof, 
          positions, 
          tree.getHexRoot()
      );
      if (!success) break;
  }
  return success;
}

async function getLeavesFromSubgraph(_startingIndex, _treeSize, client) {
  const variables = {
      startingIndex: _startingIndex,
      treeSize: _treeSize
  };

  const earnedBadgeCounts = (await client.request(EMBLEM_EARNED_BADGE_COUNT_QUERY, variables)).earnedBadgeCounts;
  return earnedBadgeCounts;
}

async function deployEmblemLibraryContract() {
  const emblemLibraryContractFactory = await ethers.getContractFactory(EMBLEM_LIBRARY_CONTRACT_NAME);
  const emblemLibraryContract = await emblemLibraryContractFactory.deploy();
  await emblemLibraryContract.deployed();
  return emblemLibraryContract;
}

async function deployEmblemLibraryTestContract() {
  // deploy library first
  const emblemLibraryContract = await deployEmblemLibraryContract();
  const emblemLibraryTestContractFactory = await ethers.getContractFactory(
    EMBLEM_LIBRARY_TEST_CONTRACT_NAME,
    {
      libraries: {
        EmblemLibrary: emblemLibraryContract.address
      }
    }
  );
  const emblemLibraryTestContract = await emblemLibraryTestContractFactory.deploy();
  await emblemLibraryTestContract.deployed();
  return emblemLibraryTestContract;
}

async function deploySubgraphControllerContract() {
  const subgraphControllerContractFactory = await ethers.getContractFactory(EMBLEM_SUBGRAPH_CONTROLLER_CONTRACT_NAME);
  const subgraphControllerContract = await subgraphControllerContractFactory.deploy(
    "0x2890bA17EfE978480615e330ecB65333b880928e",
    "0x3d1d3E34f7fB6D26245E6640E1c50710eFFf15bA"
  );
  await subgraphControllerContract.deployed();
  return subgraphControllerContract;
}